{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yaml12 \u00b6 A YAML 1.2 parser/formatter for Python, implemented in Rust for speed and correctness. Built on the excellent saphyr crate. For almost every use case, yaml12 lets you work with plain builtin Python types end to end: dict , list , int , float , str , and None . Parse YAML text or files with parse_yaml() and read_yaml() . Serialize Python values with format_yaml() or write_yaml() . 100% compliance with the yaml-test-suite . Advanced YAML features (document streams, tags, complex mapping keys) are supported and round-trip cleanly when needed; see the advanced guide if needed. Installation \u00b6 Install from PyPI: pip install py-yaml12 For development, install from the repository root (requires Python 3.10+ and a Rust toolchain): python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -e . --no-build-isolation Quick start \u00b6 from yaml12 import parse_yaml, format_yaml yaml_text = \"\"\" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] features: tags: preserve streams: multi \"\"\" doc = parse_yaml(yaml_text) assert doc == { \"title\": \"A modern YAML parser and emitter written in Rust\", \"properties\": [\"fast\", \"correct\", \"safe\", \"simple\"], \"features\": {\"tags\": \"preserve\", \"streams\": \"multi\"}, } text = format_yaml(doc) print(text) # title: A modern YAML parser and emitter written in Rust # properties: # - fast # - correct # - safe # - simple # features: # tags: preserve # streams: multi Reading and writing files \u00b6 from yaml12 import read_yaml, write_yaml value_out = {\"alpha\": 1, \"nested\": [True, None]} write_yaml(value_out, \"my.yaml\") value_in = read_yaml(\"my.yaml\") assert value_in == value_out # Multi-document streams docs_out = [{\"foo\": 1}, {\"bar\": [2, None]}] write_yaml(docs_out, \"my-multi.yaml\", multi=True) docs_in = read_yaml(\"my-multi.yaml\", multi=True) assert docs_in == docs_out Tag handlers \u00b6 Handlers let you opt into custom behaviour for tagged nodes while keeping the default parser strict and safe. from yaml12 import parse_yaml yaml_text = \"\"\" - !upper [rust, python] - !expr 6 * 7 \"\"\" handlers = { \"!expr\": lambda value: eval(value), \"!upper\": lambda value: [x.upper() for x in value], } doc = parse_yaml(yaml_text, handlers=handlers) assert doc == [[\"RUST\", \"PYTHON\"], 42] Formatting and round-tripping \u00b6 from yaml12 import format_yaml, parse_yaml, Yaml obj = { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(value=\"1 + 1\", tag=\"!expr\"), } yaml_text = format_yaml(obj) print(yaml_text) # seq: # - 1 # - 2 # map: # key: value # tagged: !expr 1 + 1 parsed = parse_yaml(yaml_text) assert parsed == { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(\"1 + 1\", \"!expr\"), } Tagged nodes and mapping keys (advanced) \u00b6 Tags, custom handlers, and non-string mapping keys work without extra setup when you need them. Nodes that can\u2019t be represented as plain Python types are wrapped in Yaml (a small immutable wrapper class). You\u2019ll only see Yaml when: A tagged node has no matching handler; inspect .value and .tag . A mapping key is a collection or otherwise unhashable; wrapping in Yaml() makes it hashable. from yaml12 import Yaml, format_yaml, parse_yaml mapping = {Yaml(\"tagged-key\", \"!k\"): \"v\"} assert parse_yaml(format_yaml(mapping)) == mapping See the advanced guide for details. Documentation \u00b6 YAML in 2 Minutes for a quick primer. Tags, Anchors, and Advanced YAML for handlers, mapping keys, document streams, and advanced tags. Reference for detailed signatures and examples. Contributing for building or serving the docs locally.","title":"Overview"},{"location":"#yaml12","text":"A YAML 1.2 parser/formatter for Python, implemented in Rust for speed and correctness. Built on the excellent saphyr crate. For almost every use case, yaml12 lets you work with plain builtin Python types end to end: dict , list , int , float , str , and None . Parse YAML text or files with parse_yaml() and read_yaml() . Serialize Python values with format_yaml() or write_yaml() . 100% compliance with the yaml-test-suite . Advanced YAML features (document streams, tags, complex mapping keys) are supported and round-trip cleanly when needed; see the advanced guide if needed.","title":"yaml12"},{"location":"#installation","text":"Install from PyPI: pip install py-yaml12 For development, install from the repository root (requires Python 3.10+ and a Rust toolchain): python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -e . --no-build-isolation","title":"Installation"},{"location":"#quick-start","text":"from yaml12 import parse_yaml, format_yaml yaml_text = \"\"\" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] features: tags: preserve streams: multi \"\"\" doc = parse_yaml(yaml_text) assert doc == { \"title\": \"A modern YAML parser and emitter written in Rust\", \"properties\": [\"fast\", \"correct\", \"safe\", \"simple\"], \"features\": {\"tags\": \"preserve\", \"streams\": \"multi\"}, } text = format_yaml(doc) print(text) # title: A modern YAML parser and emitter written in Rust # properties: # - fast # - correct # - safe # - simple # features: # tags: preserve # streams: multi","title":"Quick start"},{"location":"#reading-and-writing-files","text":"from yaml12 import read_yaml, write_yaml value_out = {\"alpha\": 1, \"nested\": [True, None]} write_yaml(value_out, \"my.yaml\") value_in = read_yaml(\"my.yaml\") assert value_in == value_out # Multi-document streams docs_out = [{\"foo\": 1}, {\"bar\": [2, None]}] write_yaml(docs_out, \"my-multi.yaml\", multi=True) docs_in = read_yaml(\"my-multi.yaml\", multi=True) assert docs_in == docs_out","title":"Reading and writing files"},{"location":"#tag-handlers","text":"Handlers let you opt into custom behaviour for tagged nodes while keeping the default parser strict and safe. from yaml12 import parse_yaml yaml_text = \"\"\" - !upper [rust, python] - !expr 6 * 7 \"\"\" handlers = { \"!expr\": lambda value: eval(value), \"!upper\": lambda value: [x.upper() for x in value], } doc = parse_yaml(yaml_text, handlers=handlers) assert doc == [[\"RUST\", \"PYTHON\"], 42]","title":"Tag handlers"},{"location":"#formatting-and-round-tripping","text":"from yaml12 import format_yaml, parse_yaml, Yaml obj = { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(value=\"1 + 1\", tag=\"!expr\"), } yaml_text = format_yaml(obj) print(yaml_text) # seq: # - 1 # - 2 # map: # key: value # tagged: !expr 1 + 1 parsed = parse_yaml(yaml_text) assert parsed == { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(\"1 + 1\", \"!expr\"), }","title":"Formatting and round-tripping"},{"location":"#tagged-nodes-and-mapping-keys-advanced","text":"Tags, custom handlers, and non-string mapping keys work without extra setup when you need them. Nodes that can\u2019t be represented as plain Python types are wrapped in Yaml (a small immutable wrapper class). You\u2019ll only see Yaml when: A tagged node has no matching handler; inspect .value and .tag . A mapping key is a collection or otherwise unhashable; wrapping in Yaml() makes it hashable. from yaml12 import Yaml, format_yaml, parse_yaml mapping = {Yaml(\"tagged-key\", \"!k\"): \"v\"} assert parse_yaml(format_yaml(mapping)) == mapping See the advanced guide for details.","title":"Tagged nodes and mapping keys (advanced)"},{"location":"#documentation","text":"YAML in 2 Minutes for a quick primer. Tags, Anchors, and Advanced YAML for handlers, mapping keys, document streams, and advanced tags. Reference for detailed signatures and examples. Contributing for building or serving the docs locally.","title":"Documentation"},{"location":"api/","text":"API Reference (now under \"Reference\" in the nav) \u00b6 The detailed API pages now live in the Reference section: parse_yaml() and read_yaml() format_yaml() and write_yaml() Yaml is the single wrapper type for tagged nodes and unhashable mapping keys. Use plain Python types whenever possible; reach for Yaml when you need to preserve a tag or keep a list/dict hashable as a mapping key. For a quick overview of the surface area, see Reference .","title":"API Reference (now under \"Reference\" in the nav)"},{"location":"api/#api-reference-now-under-reference-in-the-nav","text":"The detailed API pages now live in the Reference section: parse_yaml() and read_yaml() format_yaml() and write_yaml() Yaml is the single wrapper type for tagged nodes and unhashable mapping keys. Use plain Python types whenever possible; reach for Yaml when you need to preserve a tag or keep a list/dict hashable as a mapping key. For a quick overview of the surface area, see Reference .","title":"API Reference (now under \"Reference\" in the nav)"},{"location":"authors/","text":"Authors and Citation \u00b6 Authors \u00b6 Tomasz Kalinowski - Author, maintainer. Posit Software, PBC - Copyright holder, funder. Citation \u00b6 Kalinowski T (2025). yaml12: Fast YAML 1.2 Parser and Formatter for Python . Python package version 0.1.0. @software{kalinowski_yaml12_python_2025, title = {yaml12: Fast YAML 1.2 Parser and Formatter for Python}, author = {Tomasz Kalinowski}, year = {2025}, version = {0.1.0}, url = {https://github.com/posit-dev/py-yaml12} }","title":"Authors and Citation"},{"location":"authors/#authors-and-citation","text":"","title":"Authors and Citation"},{"location":"authors/#authors","text":"Tomasz Kalinowski - Author, maintainer. Posit Software, PBC - Copyright holder, funder.","title":"Authors"},{"location":"authors/#citation","text":"Kalinowski T (2025). yaml12: Fast YAML 1.2 Parser and Formatter for Python . Python package version 0.1.0. @software{kalinowski_yaml12_python_2025, title = {yaml12: Fast YAML 1.2 Parser and Formatter for Python}, author = {Tomasz Kalinowski}, year = {2025}, version = {0.1.0}, url = {https://github.com/posit-dev/py-yaml12} }","title":"Citation"},{"location":"contributing/","text":"Contributing \u00b6 Build or serve the docs locally \u00b6 Install MkDocs if you have not already: python -m pip install mkdocs Then from the project root: # Build static site into ./site .venv/bin/mkdocs build # Serve with live reload at http://127.0.0.1:8000 .venv/bin/mkdocs serve","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#build-or-serve-the-docs-locally","text":"Install MkDocs if you have not already: python -m pip install mkdocs Then from the project root: # Build static site into ./site .venv/bin/mkdocs build # Serve with live reload at http://127.0.0.1:8000 .venv/bin/mkdocs serve","title":"Build or serve the docs locally"},{"location":"tags/","text":"YAML Tags, Anchors, and Advanced Features with yaml12 \u00b6 This guide picks up where the \u201cYAML in 2 Minutes\u201d intro leaves off. It explains what YAML tags are and how to work with them in yaml12 using tag handlers. Along the way we also cover complex mapping keys, document streams, and anchors, so you can handle real-world YAML 1.2. Tags in YAML and how yaml12 handles them \u00b6 Tags annotate any YAML node with extra meaning. In YAML syntax a tag always starts with ! , and it appears before the node\u2019s value; it is not part of the scalar text itself. yaml12 preserves tags by wrapping nodes in a Yaml object. A Yaml is a small immutable wrapper class that carries the parsed value (a regular Python type) and the tag string. Here is an example of parsing a tagged scalar: from yaml12 import Yaml, parse_yaml color = parse_yaml(\"!color red\") assert isinstance(color, Yaml) and (color.tag, color.value) == (\"!color\", \"red\") The presence of a custom tag bypasses the usual scalar typing: the scalar is returned as a string even if it looks like another type. assert parse_yaml(\"! true\") == Yaml(value=\"true\", tag=\"!\") assert parse_yaml(\"true\") is True Using handlers to transform tagged nodes while parsing \u00b6 parse_yaml() and read_yaml() accept handlers : a dict mapping tag strings to callables. Handlers run on any matching tagged node. For tagged scalars the handler receives a plain Python scalar; for tagged sequences or mappings, it receives a plain list or dict. Here is an example of using a handler to evaluate !expr nodes: from yaml12 import parse_yaml handlers = {\"!expr\": lambda value: eval(str(value))} assert parse_yaml(\"!expr 1 + 1\", handlers=handlers) == 2 Any errors from a handler stop parsing and propagate unchanged: from yaml12 import parse_yaml def boom(value): raise ValueError(\"boom\") parse_yaml(\"!boom 1\", handlers={\"!boom\": boom}) # ValueError(\"boom\") Any tag without a matching handler is left preserved as a Yaml object, and handlers without matching tags are simply unused: from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !expr 1 + 1 - !upper yaml is awesome - !note this tag has no handler \"\"\" handlers = { \"!expr\": lambda value: eval(str(value)), \"!upper\": str.upper, \"!lower\": str.lower, # unused } out = parse_yaml(yaml_text, handlers=handlers) assert out == [2, \"YAML IS AWESOME\", Yaml(\"this tag has no handler\", \"!note\")] With a tagged sequence or mapping, the handler is called with a plain list or dict: from yaml12 import parse_yaml def seq_handler(value): assert value == [\"a\", \"b\"] return \"handled-seq\" def map_handler(value): assert value == {\"key1\": 1, \"key2\": 2} return \"handled-map\" yaml_text = \"\"\" - !some_seq_tag [a, b] - !some_map_tag {key1: 1, key2: 2} \"\"\" out = parse_yaml( yaml_text, handlers={ \"!some_seq_tag\": seq_handler, \"!some_map_tag\": map_handler, }, ) assert out == [\"handled-seq\", \"handled-map\"] Handlers apply to both values and keys, including the non-specific ! tag if you register \"!\" . If a handler raises an exception, parsing stops and you see the exception unchanged, which makes debugging easy. Any tag without a matching handler stays as a Yaml object, and any unused handlers are simply ignored. Handlers make it easy to opt into powerful behaviors while keeping the default parser strict and safe. Post-process tags yourself \u00b6 If you want more control, you can parse without handlers and then walk the result yourself. For example, here is a tiny post-processor for !expr scalars: from yaml12 import Yaml, parse_yaml def eval_yaml_expr_nodes(obj): if isinstance(obj, Yaml): if obj.tag == \"!expr\": return eval(str(obj.value)) return Yaml(eval_yaml_expr_nodes(obj.value), obj.tag) if isinstance(obj, list): return [eval_yaml_expr_nodes(item) for item in obj] if isinstance(obj, dict): return {eval_yaml_expr_nodes(k): eval_yaml_expr_nodes(v) for k, v in obj.items()} return obj raw = parse_yaml(\"!expr 1 + 1\") assert isinstance(raw, Yaml) and eval_yaml_expr_nodes(raw) == 2 Because tags can also appear on mapping keys, postprocessors should walk dict keys as well (as in the example above). If you transform all tagged keys into plain hashable scalars, you can rebuild a dict with those new keys. Mappings revisited: non-string keys and Yaml \u00b6 In YAML, mapping keys do not have to be plain strings; any node can be a key, including booleans, numbers, sequences, or other mappings. For example, this is valid YAML even though the key is a boolean: true: true When a key can\u2019t be represented directly as a plain Python dict key, yaml12 wraps it in Yaml . That preserves the original key and makes it hashable (with equality defined by structure, including mapping key order), so it can safely live in a Python dict : parsed = parse_yaml(\"true: true\") key = next(iter(parsed)) assert key is True and parsed[key] is True and not isinstance(key, Yaml) For complex key values, YAML uses the explicit mapping-key indicator ? : ? [a, b] : tuple ? {x: 1, y: 2} : map-key Becomes: from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" ? [a, b] : tuple ? {x: 1, y: 2} : map-key \"\"\" parsed = parse_yaml(yaml_text) seq_key, map_key = list(parsed) assert isinstance(seq_key, Yaml) and seq_key.value == [\"a\", \"b\"] assert isinstance(map_key, Yaml) and map_key.value == {\"x\": 1, \"y\": 2} assert parsed[Yaml([\"a\", \"b\"])] == \"tuple\" assert parsed[Yaml({\"x\": 1, \"y\": 2})] == \"map-key\" Tagged mapping keys \u00b6 Handlers run on keys too, so a handler can turn tagged keys into friendly Python keys before they are wrapped. handlers = {\"!upper\": str.upper} result = parse_yaml(\"!upper key: value\", handlers=handlers) assert result == {\"KEY\": \"value\"} If a tagged key has no matching handler, it is preserved as a Yaml key: from yaml12 import Yaml, parse_yaml parsed = parse_yaml(\"!custom foo: 1\") key = next(iter(parsed)) assert isinstance(key, Yaml) and key.tag == \"!custom\" and key.value == \"foo\" If you anticipate tagged mapping keys that you want to process yourself, walk the Yaml keys alongside the values and unwrap them as needed. Document streams and markers \u00b6 Most YAML files contain a single YAML document . YAML also supports document streams : multiple documents separated by --- and optionally closed by ... . Reading multiple documents \u00b6 parse_yaml() and read_yaml() default to multi=False . In that mode, they stop after the first document. When multi=True , all documents in the stream are returned as a list. doc_stream = \"\"\" --- doc 1 --- doc 2 \"\"\" parsed_first = parse_yaml(doc_stream) parsed_all = parse_yaml(doc_stream, multi=True) assert (parsed_first, parsed_all) == (\"doc 1\", [\"doc 1\", \"doc 2\"]) Writing multiple documents \u00b6 write_yaml() and format_yaml() also default to a single document. With multi=True , the value must be a sequence of documents and the output uses --- between documents and ... after the final one. For single documents, write_yaml() always wraps the body with --- and a final ... , while format_yaml() returns just the body. from yaml12 import format_yaml, write_yaml docs = [\"first\", \"second\"] text = format_yaml(docs, multi=True) assert text.startswith(\"---\") and text.rstrip().endswith(\"...\") write_yaml(docs, path=\"out.yml\", multi=True) When multi=False , parsing stops after the first document\u2014even if later content is not valid YAML. That makes it easy to extract front matter from files that mix YAML with other text (like Markdown). rmd_lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] frontmatter = parse_yaml(\"\\n\".join(rmd_lines)) assert frontmatter == {\"title\": \"Front matter only\", \"params\": {\"answer\": 42}} Writing YAML with tags \u00b6 To emit a tag, wrap a value in Yaml before calling format_yaml() or write_yaml() . from yaml12 import Yaml, write_yaml tagged = Yaml(\"1 + x\", \"!expr\") write_yaml(tagged) # stdout: # --- # !expr 1 + x # ... Tagged collections or mapping keys work the same way: from yaml12 import Yaml, format_yaml, parse_yaml mapping = { \"tagged_value\": Yaml([\"a\", \"b\"], \"!pair\"), Yaml(\"tagged-key\", \"!k\"): \"v\", } encoded = format_yaml(mapping) reparsed = parse_yaml(encoded) value = reparsed[\"tagged_value\"] assert isinstance(value, Yaml) and value.tag == \"!pair\" and value.value == [\"a\", \"b\"] key = next(k for k in reparsed if isinstance(k, Yaml)) assert key.tag == \"!k\" and key.value == \"tagged-key\" and reparsed[key] == \"v\" Serializing custom Python objects \u00b6 You can opt into richer domain types by tagging your own objects on emit and supplying a handler on parse. Here is a round-trip for a dataclass: from dataclasses import dataclass, asdict from yaml12 import Yaml, format_yaml, parse_yaml @dataclass class Server: name: str host: str port: int def encode_server(server: Server) -> Yaml: return Yaml(asdict(server), \"!server\") def decode_server(value): return Server(**value) servers = [Server(\"api\", \"api.example.com\", 8000), Server(\"db\", \"db.local\", 5432)] yaml_text = format_yaml([encode_server(s) for s in servers]) round_tripped = parse_yaml(yaml_text, handlers={\"!server\": decode_server}) assert round_tripped == servers By keeping the on-disk representation a plain mapping plus tag, you get a stable YAML format while still round-tripping your Python types losslessly. Anchors \u00b6 Anchors ( &id ) name a node; aliases ( *id ) copy it. yaml12 resolves aliases before returning Python objects. from yaml12 import parse_yaml parsed = parse_yaml(\"\"\" recycle-me: &anchor-name a: b c: d recycled: - *anchor-name - *anchor-name \"\"\") first, second = parsed[\"recycled\"] assert first[\"a\"] == \"b\" and second[\"c\"] == \"d\" Debugging \u00b6 If you want to inspect how YAML nodes are parsed before conversion to Python types, use the internal helper yaml12._dbg_yaml() to pretty-print the raw saphyr::Yaml structures: import yaml12 yaml12._dbg_yaml(\"!custom [1, 2]\") _dbg_yaml is intended for debugging and may change without notice. (Very) advanced tags \u00b6 The following YAML features are uncommon, but yaml12 supports them for full YAML 1.2 compliance. Tag directives ( %TAG ) \u00b6 YAML lets you declare tag handles at the top of a document. The syntax is %TAG !<name>! <handle> and it applies to the rest of the document. text = \"\"\" %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo \"\"\" parsed = parse_yaml(text) assert parsed[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" You can also declare a global tag prefix, which expands a bare ! : text = \"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo \"\"\" assert parse_yaml(text)[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" Tag URIs \u00b6 To specify a verbatim tag, use !<...> with a valid URI-like string. For simple tags like gizmo , yaml12 normalizes !<gizmo> to the local tag form !gizmo : parsed = parse_yaml(\"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo \"\"\") assert parsed[\"item\"].tag == \"!gizmo\" Core schema tags \u00b6 Tags beginning with !! resolve against the YAML core schema handle ( tag:yaml.org,2002: ). Scalar core tags ( !!str , !!int , !!float , !!bool , !!null , !!seq , !!map ) add no information when emitting and are normalized to plain Python values. Informative core tags ( !!timestamp , !!binary , !!set , !!omap , !!pairs ) stay tagged so you can decide how to handle them. YAML 1.2 removed these informative tags from the core schema, but they are still valid tags and occasionally useful. yaml12 preserves them as Yaml unless you supply a handler to convert them to richer Python types. from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10-05:00 - !!binary UiBpcyBBd2Vzb21l \"\"\" parsed = parse_yaml(yaml_text) assert all(isinstance(item, Yaml) for item in parsed) and ( parsed[0].tag, parsed[2].tag, ) == (\"tag:yaml.org,2002:timestamp\", \"tag:yaml.org,2002:binary\") Handlers can convert these to richer Python types: import base64 from datetime import datetime, timezone from yaml12 import parse_yaml def ts_handler(value): return datetime.fromisoformat(str(value).replace(\"Z\", \"+00:00\")).replace(tzinfo=timezone.utc) def binary_handler(value): return base64.b64decode(str(value)) converted = parse_yaml( yaml_text, handlers={ \"!!timestamp\": ts_handler, \"!!binary\": binary_handler, }, ) assert isinstance(converted[0], datetime) and isinstance(converted[2], (bytes, bytearray))","title":"Tags, Anchors, and Advanced YAML"},{"location":"tags/#yaml-tags-anchors-and-advanced-features-with-yaml12","text":"This guide picks up where the \u201cYAML in 2 Minutes\u201d intro leaves off. It explains what YAML tags are and how to work with them in yaml12 using tag handlers. Along the way we also cover complex mapping keys, document streams, and anchors, so you can handle real-world YAML 1.2.","title":"YAML Tags, Anchors, and Advanced Features with yaml12"},{"location":"tags/#tags-in-yaml-and-how-yaml12-handles-them","text":"Tags annotate any YAML node with extra meaning. In YAML syntax a tag always starts with ! , and it appears before the node\u2019s value; it is not part of the scalar text itself. yaml12 preserves tags by wrapping nodes in a Yaml object. A Yaml is a small immutable wrapper class that carries the parsed value (a regular Python type) and the tag string. Here is an example of parsing a tagged scalar: from yaml12 import Yaml, parse_yaml color = parse_yaml(\"!color red\") assert isinstance(color, Yaml) and (color.tag, color.value) == (\"!color\", \"red\") The presence of a custom tag bypasses the usual scalar typing: the scalar is returned as a string even if it looks like another type. assert parse_yaml(\"! true\") == Yaml(value=\"true\", tag=\"!\") assert parse_yaml(\"true\") is True","title":"Tags in YAML and how yaml12 handles them"},{"location":"tags/#using-handlers-to-transform-tagged-nodes-while-parsing","text":"parse_yaml() and read_yaml() accept handlers : a dict mapping tag strings to callables. Handlers run on any matching tagged node. For tagged scalars the handler receives a plain Python scalar; for tagged sequences or mappings, it receives a plain list or dict. Here is an example of using a handler to evaluate !expr nodes: from yaml12 import parse_yaml handlers = {\"!expr\": lambda value: eval(str(value))} assert parse_yaml(\"!expr 1 + 1\", handlers=handlers) == 2 Any errors from a handler stop parsing and propagate unchanged: from yaml12 import parse_yaml def boom(value): raise ValueError(\"boom\") parse_yaml(\"!boom 1\", handlers={\"!boom\": boom}) # ValueError(\"boom\") Any tag without a matching handler is left preserved as a Yaml object, and handlers without matching tags are simply unused: from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !expr 1 + 1 - !upper yaml is awesome - !note this tag has no handler \"\"\" handlers = { \"!expr\": lambda value: eval(str(value)), \"!upper\": str.upper, \"!lower\": str.lower, # unused } out = parse_yaml(yaml_text, handlers=handlers) assert out == [2, \"YAML IS AWESOME\", Yaml(\"this tag has no handler\", \"!note\")] With a tagged sequence or mapping, the handler is called with a plain list or dict: from yaml12 import parse_yaml def seq_handler(value): assert value == [\"a\", \"b\"] return \"handled-seq\" def map_handler(value): assert value == {\"key1\": 1, \"key2\": 2} return \"handled-map\" yaml_text = \"\"\" - !some_seq_tag [a, b] - !some_map_tag {key1: 1, key2: 2} \"\"\" out = parse_yaml( yaml_text, handlers={ \"!some_seq_tag\": seq_handler, \"!some_map_tag\": map_handler, }, ) assert out == [\"handled-seq\", \"handled-map\"] Handlers apply to both values and keys, including the non-specific ! tag if you register \"!\" . If a handler raises an exception, parsing stops and you see the exception unchanged, which makes debugging easy. Any tag without a matching handler stays as a Yaml object, and any unused handlers are simply ignored. Handlers make it easy to opt into powerful behaviors while keeping the default parser strict and safe.","title":"Using handlers to transform tagged nodes while parsing"},{"location":"tags/#post-process-tags-yourself","text":"If you want more control, you can parse without handlers and then walk the result yourself. For example, here is a tiny post-processor for !expr scalars: from yaml12 import Yaml, parse_yaml def eval_yaml_expr_nodes(obj): if isinstance(obj, Yaml): if obj.tag == \"!expr\": return eval(str(obj.value)) return Yaml(eval_yaml_expr_nodes(obj.value), obj.tag) if isinstance(obj, list): return [eval_yaml_expr_nodes(item) for item in obj] if isinstance(obj, dict): return {eval_yaml_expr_nodes(k): eval_yaml_expr_nodes(v) for k, v in obj.items()} return obj raw = parse_yaml(\"!expr 1 + 1\") assert isinstance(raw, Yaml) and eval_yaml_expr_nodes(raw) == 2 Because tags can also appear on mapping keys, postprocessors should walk dict keys as well (as in the example above). If you transform all tagged keys into plain hashable scalars, you can rebuild a dict with those new keys.","title":"Post-process tags yourself"},{"location":"tags/#mappings-revisited-non-string-keys-and-yaml","text":"In YAML, mapping keys do not have to be plain strings; any node can be a key, including booleans, numbers, sequences, or other mappings. For example, this is valid YAML even though the key is a boolean: true: true When a key can\u2019t be represented directly as a plain Python dict key, yaml12 wraps it in Yaml . That preserves the original key and makes it hashable (with equality defined by structure, including mapping key order), so it can safely live in a Python dict : parsed = parse_yaml(\"true: true\") key = next(iter(parsed)) assert key is True and parsed[key] is True and not isinstance(key, Yaml) For complex key values, YAML uses the explicit mapping-key indicator ? : ? [a, b] : tuple ? {x: 1, y: 2} : map-key Becomes: from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" ? [a, b] : tuple ? {x: 1, y: 2} : map-key \"\"\" parsed = parse_yaml(yaml_text) seq_key, map_key = list(parsed) assert isinstance(seq_key, Yaml) and seq_key.value == [\"a\", \"b\"] assert isinstance(map_key, Yaml) and map_key.value == {\"x\": 1, \"y\": 2} assert parsed[Yaml([\"a\", \"b\"])] == \"tuple\" assert parsed[Yaml({\"x\": 1, \"y\": 2})] == \"map-key\"","title":"Mappings revisited: non-string keys and Yaml"},{"location":"tags/#tagged-mapping-keys","text":"Handlers run on keys too, so a handler can turn tagged keys into friendly Python keys before they are wrapped. handlers = {\"!upper\": str.upper} result = parse_yaml(\"!upper key: value\", handlers=handlers) assert result == {\"KEY\": \"value\"} If a tagged key has no matching handler, it is preserved as a Yaml key: from yaml12 import Yaml, parse_yaml parsed = parse_yaml(\"!custom foo: 1\") key = next(iter(parsed)) assert isinstance(key, Yaml) and key.tag == \"!custom\" and key.value == \"foo\" If you anticipate tagged mapping keys that you want to process yourself, walk the Yaml keys alongside the values and unwrap them as needed.","title":"Tagged mapping keys"},{"location":"tags/#document-streams-and-markers","text":"Most YAML files contain a single YAML document . YAML also supports document streams : multiple documents separated by --- and optionally closed by ... .","title":"Document streams and markers"},{"location":"tags/#reading-multiple-documents","text":"parse_yaml() and read_yaml() default to multi=False . In that mode, they stop after the first document. When multi=True , all documents in the stream are returned as a list. doc_stream = \"\"\" --- doc 1 --- doc 2 \"\"\" parsed_first = parse_yaml(doc_stream) parsed_all = parse_yaml(doc_stream, multi=True) assert (parsed_first, parsed_all) == (\"doc 1\", [\"doc 1\", \"doc 2\"])","title":"Reading multiple documents"},{"location":"tags/#writing-multiple-documents","text":"write_yaml() and format_yaml() also default to a single document. With multi=True , the value must be a sequence of documents and the output uses --- between documents and ... after the final one. For single documents, write_yaml() always wraps the body with --- and a final ... , while format_yaml() returns just the body. from yaml12 import format_yaml, write_yaml docs = [\"first\", \"second\"] text = format_yaml(docs, multi=True) assert text.startswith(\"---\") and text.rstrip().endswith(\"...\") write_yaml(docs, path=\"out.yml\", multi=True) When multi=False , parsing stops after the first document\u2014even if later content is not valid YAML. That makes it easy to extract front matter from files that mix YAML with other text (like Markdown). rmd_lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] frontmatter = parse_yaml(\"\\n\".join(rmd_lines)) assert frontmatter == {\"title\": \"Front matter only\", \"params\": {\"answer\": 42}}","title":"Writing multiple documents"},{"location":"tags/#writing-yaml-with-tags","text":"To emit a tag, wrap a value in Yaml before calling format_yaml() or write_yaml() . from yaml12 import Yaml, write_yaml tagged = Yaml(\"1 + x\", \"!expr\") write_yaml(tagged) # stdout: # --- # !expr 1 + x # ... Tagged collections or mapping keys work the same way: from yaml12 import Yaml, format_yaml, parse_yaml mapping = { \"tagged_value\": Yaml([\"a\", \"b\"], \"!pair\"), Yaml(\"tagged-key\", \"!k\"): \"v\", } encoded = format_yaml(mapping) reparsed = parse_yaml(encoded) value = reparsed[\"tagged_value\"] assert isinstance(value, Yaml) and value.tag == \"!pair\" and value.value == [\"a\", \"b\"] key = next(k for k in reparsed if isinstance(k, Yaml)) assert key.tag == \"!k\" and key.value == \"tagged-key\" and reparsed[key] == \"v\"","title":"Writing YAML with tags"},{"location":"tags/#serializing-custom-python-objects","text":"You can opt into richer domain types by tagging your own objects on emit and supplying a handler on parse. Here is a round-trip for a dataclass: from dataclasses import dataclass, asdict from yaml12 import Yaml, format_yaml, parse_yaml @dataclass class Server: name: str host: str port: int def encode_server(server: Server) -> Yaml: return Yaml(asdict(server), \"!server\") def decode_server(value): return Server(**value) servers = [Server(\"api\", \"api.example.com\", 8000), Server(\"db\", \"db.local\", 5432)] yaml_text = format_yaml([encode_server(s) for s in servers]) round_tripped = parse_yaml(yaml_text, handlers={\"!server\": decode_server}) assert round_tripped == servers By keeping the on-disk representation a plain mapping plus tag, you get a stable YAML format while still round-tripping your Python types losslessly.","title":"Serializing custom Python objects"},{"location":"tags/#anchors","text":"Anchors ( &id ) name a node; aliases ( *id ) copy it. yaml12 resolves aliases before returning Python objects. from yaml12 import parse_yaml parsed = parse_yaml(\"\"\" recycle-me: &anchor-name a: b c: d recycled: - *anchor-name - *anchor-name \"\"\") first, second = parsed[\"recycled\"] assert first[\"a\"] == \"b\" and second[\"c\"] == \"d\"","title":"Anchors"},{"location":"tags/#debugging","text":"If you want to inspect how YAML nodes are parsed before conversion to Python types, use the internal helper yaml12._dbg_yaml() to pretty-print the raw saphyr::Yaml structures: import yaml12 yaml12._dbg_yaml(\"!custom [1, 2]\") _dbg_yaml is intended for debugging and may change without notice.","title":"Debugging"},{"location":"tags/#very-advanced-tags","text":"The following YAML features are uncommon, but yaml12 supports them for full YAML 1.2 compliance.","title":"(Very) advanced tags"},{"location":"tags/#tag-directives-tag","text":"YAML lets you declare tag handles at the top of a document. The syntax is %TAG !<name>! <handle> and it applies to the rest of the document. text = \"\"\" %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo \"\"\" parsed = parse_yaml(text) assert parsed[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" You can also declare a global tag prefix, which expands a bare ! : text = \"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo \"\"\" assert parse_yaml(text)[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\"","title":"Tag directives (%TAG)"},{"location":"tags/#tag-uris","text":"To specify a verbatim tag, use !<...> with a valid URI-like string. For simple tags like gizmo , yaml12 normalizes !<gizmo> to the local tag form !gizmo : parsed = parse_yaml(\"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo \"\"\") assert parsed[\"item\"].tag == \"!gizmo\"","title":"Tag URIs"},{"location":"tags/#core-schema-tags","text":"Tags beginning with !! resolve against the YAML core schema handle ( tag:yaml.org,2002: ). Scalar core tags ( !!str , !!int , !!float , !!bool , !!null , !!seq , !!map ) add no information when emitting and are normalized to plain Python values. Informative core tags ( !!timestamp , !!binary , !!set , !!omap , !!pairs ) stay tagged so you can decide how to handle them. YAML 1.2 removed these informative tags from the core schema, but they are still valid tags and occasionally useful. yaml12 preserves them as Yaml unless you supply a handler to convert them to richer Python types. from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10-05:00 - !!binary UiBpcyBBd2Vzb21l \"\"\" parsed = parse_yaml(yaml_text) assert all(isinstance(item, Yaml) for item in parsed) and ( parsed[0].tag, parsed[2].tag, ) == (\"tag:yaml.org,2002:timestamp\", \"tag:yaml.org,2002:binary\") Handlers can convert these to richer Python types: import base64 from datetime import datetime, timezone from yaml12 import parse_yaml def ts_handler(value): return datetime.fromisoformat(str(value).replace(\"Z\", \"+00:00\")).replace(tzinfo=timezone.utc) def binary_handler(value): return base64.b64decode(str(value)) converted = parse_yaml( yaml_text, handlers={ \"!!timestamp\": ts_handler, \"!!binary\": binary_handler, }, ) assert isinstance(converted[0], datetime) and isinstance(converted[2], (bytes, bytearray))","title":"Core schema tags"},{"location":"usage/","text":"YAML in 2 Minutes: A Gentle Introduction for Python Users \u00b6 from yaml12 import parse_yaml Here\u2019s a short introduction to YAML for Python users. YAML is a data serialization format designed to be easy for humans to read and write. Think of YAML as \u201cJSON with comments and nicer multiline strings.\u201d yaml12 parses YAML 1.2 (the modern specification that removes some of YAML 1.1\u2019s surprising eager conversions) into plain Python objects. YAML has three building blocks: scalars (single values), sequences (ordered collections), and mappings (key/value pairs). JSON is a subset of YAML 1.2, so all valid JSON is also valid YAML and parses the same way. A first example \u00b6 title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. Let\u2019s parse that with yaml12 : doc = parse_yaml(first_example_text) assert doc == { \"title\": \"A Modern YAML parser written in Rust\", \"properties\": [\"correct\", \"safe\", \"fast\", \"simple\"], \"score\": 9.5, \"categories\": [\"yaml\", \"python\", \"example\"], \"settings\": { \"note\": \"This is a folded block that turns line breaks into spaces.\\n\", \"note_literal\": \"This is a literal block\\nthat keeps\\nline breaks.\\n\", }, } Comments \u00b6 Comments start with # and run to the end of the line. They must be separated from values by whitespace and can sit on their own line or at line ends. yaml12 ignores them. # Whole-line comment title: example # inline comment items: [a, b] # trailing comment \u2192 {\"title\": \"example\", \"items\": [\"a\", \"b\"]} Collections \u00b6 There are two collection types: sequences and mappings . Sequences: YAML's ordered collections \u00b6 A sequence is a list of items. Each item begins with - at the parent indent. - cat - dog \u2192 [\"cat\", \"dog\"] Sequences become list s in Python. JSON-style arrays work too: [cat, dog] \u2192 same result Anything belonging to one of the sequence entries is indented at least one space past the dash: - name: cat toys: [string, box] - name: dog toys: [ball, bone] parses to: [ {\"name\": \"cat\", \"toys\": [\"string\", \"box\"]}, {\"name\": \"dog\", \"toys\": [\"ball\", \"bone\"]}, ] Mappings: key/value pairs \u00b6 A mapping is a set of key: value pairs at the same indent: foo: 1 bar: true \u2192 {\"foo\": 1, \"bar\": True} Mappings become dict s in Python. A key at its indent owns anything indented more: settings: debug: true max_items: 3 parses to {\"settings\": {\"debug\": True, \"max_items\": 3}} . JSON-style objects work too: {a: true} \u2192 {\"a\": True} Scalars \u00b6 All nodes that are not collections are scalars; these are the leaf values of a YAML document. Scalars can come in three forms: block, quoted, or plain. Block scalars \u00b6 | starts a literal block that keeps newlines; > starts a folded block that joins lines with spaces (except blank/indented lines keep breaks). Block scalars always become strings. | hello world \u2192 \"hello\\nworld\\n\" > hello world \u2192 \"hello world\\n\" Quoted scalars \u00b6 Quoted scalars always become strings. Double quotes interpret escapes ( \\n , \\t , \\\\ , \\\" ). Single quotes are literal and do not interpret escapes, except for '' which is parsed as a single ' . [\"line\\nbreak\", \"quote: \\\"here\\\"\"] \u2192 [\"line\\nbreak\", 'quote: \"here\"'] ['line\\nbreak', 'quote: ''here'''] \u2192 [\"line\\\\nbreak\", \"quote: 'here'\"] Plain (unquoted) scalars \u00b6 Plain (unquoted) nodes can resolve to one of five types: string, int, float, bool, or null. true / false -> True / False null , ~ , or empty -> None numbers: signed, decimal, scientific, hex ( 0x ), octal ( 0o ), .inf , .nan -> int or float everything else stays a string ( yes , no , on , off and other aliases remain strings in YAML 1.2) [true, 123, 4.5e2, 0x10, .inf, yes] \u2192 [True, 123, 450.0, 16, float(\"inf\"), \"yes\"] End-to-end example \u00b6 doc: pets: - cat - dog numbers: [1, 2.5, 0x10, .inf, null] integers: [1, 2, 3, 0x10, null] flags: {enabled: true, label: on} literal: | hello world folded: > hello world quoted: - \"line\\nbreak\" - 'quote: ''here''' plain: [yes, no] mixed: [won't simplify, 123, true] Python result ( parse_yaml() with defaults): { \"doc\": { \"pets\": [\"cat\", \"dog\"], \"numbers\": [1, 2.5, 16, float(\"inf\"), None], \"integers\": [1, 2, 3, 16, None], \"flags\": {\"enabled\": True, \"label\": \"on\"}, \"literal\": \"hello\\nworld\\n\", \"folded\": \"hello world\\n\", \"quoted\": [\"line\\nbreak\", \"quote: 'here'\"], \"plain\": [\"yes\", \"no\"], \"mixed\": [\"won't simplify\", 123, True], } } Quick notes \u00b6 Indentation defines structure for collections. Sibling elements share an indent; children are indented more. YAML 1.2 forbids tabs; use spaces. All JSON is valid YAML. Sequences stay Python lists; there is no vector \"simplification.\" Mapping (dict) key order is preserved on load and emit (in the order keys appear in the YAML input, and in the insertion order of Python mappings you format). Block scalars ( | , > ) always produce strings. Booleans are only true / false ; null maps to None . Numbers can be signed, scientific, hex ( 0x ), octal ( 0o ), .inf , and .nan . These essentials cover most YAML you\u2019ll run into in practice. If you encounter tags, anchors, or non-string mapping keys, the advanced guide walks through those in detail.","title":"YAML in 2 Minutes"},{"location":"usage/#yaml-in-2-minutes-a-gentle-introduction-for-python-users","text":"from yaml12 import parse_yaml Here\u2019s a short introduction to YAML for Python users. YAML is a data serialization format designed to be easy for humans to read and write. Think of YAML as \u201cJSON with comments and nicer multiline strings.\u201d yaml12 parses YAML 1.2 (the modern specification that removes some of YAML 1.1\u2019s surprising eager conversions) into plain Python objects. YAML has three building blocks: scalars (single values), sequences (ordered collections), and mappings (key/value pairs). JSON is a subset of YAML 1.2, so all valid JSON is also valid YAML and parses the same way.","title":"YAML in 2 Minutes: A Gentle Introduction for Python Users"},{"location":"usage/#a-first-example","text":"title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. Let\u2019s parse that with yaml12 : doc = parse_yaml(first_example_text) assert doc == { \"title\": \"A Modern YAML parser written in Rust\", \"properties\": [\"correct\", \"safe\", \"fast\", \"simple\"], \"score\": 9.5, \"categories\": [\"yaml\", \"python\", \"example\"], \"settings\": { \"note\": \"This is a folded block that turns line breaks into spaces.\\n\", \"note_literal\": \"This is a literal block\\nthat keeps\\nline breaks.\\n\", }, }","title":"A first example"},{"location":"usage/#comments","text":"Comments start with # and run to the end of the line. They must be separated from values by whitespace and can sit on their own line or at line ends. yaml12 ignores them. # Whole-line comment title: example # inline comment items: [a, b] # trailing comment \u2192 {\"title\": \"example\", \"items\": [\"a\", \"b\"]}","title":"Comments"},{"location":"usage/#collections","text":"There are two collection types: sequences and mappings .","title":"Collections"},{"location":"usage/#sequences-yamls-ordered-collections","text":"A sequence is a list of items. Each item begins with - at the parent indent. - cat - dog \u2192 [\"cat\", \"dog\"] Sequences become list s in Python. JSON-style arrays work too: [cat, dog] \u2192 same result Anything belonging to one of the sequence entries is indented at least one space past the dash: - name: cat toys: [string, box] - name: dog toys: [ball, bone] parses to: [ {\"name\": \"cat\", \"toys\": [\"string\", \"box\"]}, {\"name\": \"dog\", \"toys\": [\"ball\", \"bone\"]}, ]","title":"Sequences: YAML's ordered collections"},{"location":"usage/#mappings-keyvalue-pairs","text":"A mapping is a set of key: value pairs at the same indent: foo: 1 bar: true \u2192 {\"foo\": 1, \"bar\": True} Mappings become dict s in Python. A key at its indent owns anything indented more: settings: debug: true max_items: 3 parses to {\"settings\": {\"debug\": True, \"max_items\": 3}} . JSON-style objects work too: {a: true} \u2192 {\"a\": True}","title":"Mappings: key/value pairs"},{"location":"usage/#scalars","text":"All nodes that are not collections are scalars; these are the leaf values of a YAML document. Scalars can come in three forms: block, quoted, or plain.","title":"Scalars"},{"location":"usage/#block-scalars","text":"| starts a literal block that keeps newlines; > starts a folded block that joins lines with spaces (except blank/indented lines keep breaks). Block scalars always become strings. | hello world \u2192 \"hello\\nworld\\n\" > hello world \u2192 \"hello world\\n\"","title":"Block scalars"},{"location":"usage/#quoted-scalars","text":"Quoted scalars always become strings. Double quotes interpret escapes ( \\n , \\t , \\\\ , \\\" ). Single quotes are literal and do not interpret escapes, except for '' which is parsed as a single ' . [\"line\\nbreak\", \"quote: \\\"here\\\"\"] \u2192 [\"line\\nbreak\", 'quote: \"here\"'] ['line\\nbreak', 'quote: ''here'''] \u2192 [\"line\\\\nbreak\", \"quote: 'here'\"]","title":"Quoted scalars"},{"location":"usage/#plain-unquoted-scalars","text":"Plain (unquoted) nodes can resolve to one of five types: string, int, float, bool, or null. true / false -> True / False null , ~ , or empty -> None numbers: signed, decimal, scientific, hex ( 0x ), octal ( 0o ), .inf , .nan -> int or float everything else stays a string ( yes , no , on , off and other aliases remain strings in YAML 1.2) [true, 123, 4.5e2, 0x10, .inf, yes] \u2192 [True, 123, 450.0, 16, float(\"inf\"), \"yes\"]","title":"Plain (unquoted) scalars"},{"location":"usage/#end-to-end-example","text":"doc: pets: - cat - dog numbers: [1, 2.5, 0x10, .inf, null] integers: [1, 2, 3, 0x10, null] flags: {enabled: true, label: on} literal: | hello world folded: > hello world quoted: - \"line\\nbreak\" - 'quote: ''here''' plain: [yes, no] mixed: [won't simplify, 123, true] Python result ( parse_yaml() with defaults): { \"doc\": { \"pets\": [\"cat\", \"dog\"], \"numbers\": [1, 2.5, 16, float(\"inf\"), None], \"integers\": [1, 2, 3, 16, None], \"flags\": {\"enabled\": True, \"label\": \"on\"}, \"literal\": \"hello\\nworld\\n\", \"folded\": \"hello world\\n\", \"quoted\": [\"line\\nbreak\", \"quote: 'here'\"], \"plain\": [\"yes\", \"no\"], \"mixed\": [\"won't simplify\", 123, True], } }","title":"End-to-end example"},{"location":"usage/#quick-notes","text":"Indentation defines structure for collections. Sibling elements share an indent; children are indented more. YAML 1.2 forbids tabs; use spaces. All JSON is valid YAML. Sequences stay Python lists; there is no vector \"simplification.\" Mapping (dict) key order is preserved on load and emit (in the order keys appear in the YAML input, and in the insertion order of Python mappings you format). Block scalars ( | , > ) always produce strings. Booleans are only true / false ; null maps to None . Numbers can be signed, scientific, hex ( 0x ), octal ( 0o ), .inf , and .nan . These essentials cover most YAML you\u2019ll run into in practice. If you encounter tags, anchors, or non-string mapping keys, the advanced guide walks through those in detail.","title":"Quick notes"},{"location":"benchmarks/","text":"Benchmarks and Performance \u00b6 Goal \u00b6 Compare yaml12 performance against: PyYAML (defaults) PyYAML (as fast as possible) ruyaml We intentionally avoid testing semantic differences between YAML 1.1 and 1.2, as well as less-used YAML features like tags and streams. Instead, we focus on the simple default usage of each library. Operations: read : YAML file \u2192 Python object write : Python object \u2192 YAML file Reproduce \u00b6 From the repo root: make venv .venv/bin/python -m pip install py-yaml12 pyyaml ruyaml plotnine pandas jupyter ipykernel great-tables css-inline QUARTO_PYTHON=\"$PWD/.venv/bin/python3\" quarto render benchmarks.qmd Setup \u00b6 Tweak these constants for faster iterations. max_power = 15 max_time_s = 1 max_iters = 20_000 from __future__ import annotations from dataclasses import dataclass import math import os import tempfile import time from pathlib import Path from statistics import median from typing import Any, Callable, Literal import pandas as pd import ruyaml import yaml import yaml12 from great_tables import GT, loc, style from IPython.display import HTML, display from plotnine import ( aes, element_line, geom_line, geom_point, ggplot, labs, scale_x_log10, scale_y_log10, theme, theme_minimal, ) def fmt_bytes(n: float) -> str: units = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"] n = float(n) for unit in units: if abs(n) < 1024 or unit == units[-1]: if unit == \"B\": return f\"{n:.0f} {unit}\" s = f\"{n:.1f}\".rstrip(\"0\").rstrip(\".\") return f\"{s} {unit}\" n /= 1024 return f\"{n:.1f} {units[-1]}\" def round_sig(x: float, sig: int = 1) -> float: if x == 0: return 0.0 return round(x, sig - 1 - int(math.floor(math.log10(abs(x))))) def fmt_bytes_rounded(n: float) -> str: units = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"] n = float(n) for idx, unit in enumerate(units): if abs(n) < 1024 or unit == units[-1]: if unit == \"B\": return f\"{n:.0f} {unit}\" rounded = round_sig(n, 1) if rounded >= 1000 and idx + 1 < len(units): n = n / 1024 unit = units[idx + 1] rounded = round_sig(n, 1) return f\"{rounded:.0f} {unit}\" n /= 1024 return f\"{n:.1f} {units[-1]}\" def fmt_time_s(sec: float) -> str: sec = float(sec) if sec < 1e-6: return f\"{sec * 1e9:.0f} ns\" if sec < 1e-3: return f\"{sec * 1e6:.1f}\".rstrip(\"0\").rstrip(\".\") + \" \u00b5s\" if sec < 1.0: return f\"{sec * 1e3:.1f}\".rstrip(\"0\").rstrip(\".\") + \" ms\" return f\"{sec:.2f}\".rstrip(\"0\").rstrip(\".\") + \" s\" SIZE_TARGETS = tuple(10**power for power in range(4, 8)) def nearest_sizes( sizes: list[int], targets: tuple[int, ...] = SIZE_TARGETS, ) -> list[tuple[int, int]]: sizes = sorted(set(sizes)) picked: list[tuple[int, int]] = [] used: set[int] = set() for target in targets: size = min(sizes, key=lambda s: abs(s - target)) if size in used: continue used.add(size) picked.append((size, target)) return picked @dataclass(frozen=True) class BenchResult: samples_s: list[float] calls: int elapsed_s: float def bench_case( fn, *, budget_s: float, max_iters: int, ) -> BenchResult: samples: list[float] = [] calls = 0 start = time.perf_counter() while calls < max_iters: t0 = time.perf_counter() fn() t1 = time.perf_counter() samples.append(t1 - t0) calls += 1 if (t1 - start) >= budget_s: break return BenchResult(samples_s=samples, calls=calls, elapsed_s=time.perf_counter() - start) @dataclass(frozen=True) class Backend: name: str read: Callable[[str], Any] write: Callable[[Any], Any] def bench_op( op: Literal[\"read\", \"write\"], *, docs: list[dict], backends: list[Backend], budget_s: float, max_iters: int, ) -> pd.DataFrame: summary_rows: list[dict] = [] for doc in docs: arg = doc[\"path\"] if op == \"read\" else doc[\"obj\"] for backend in backends: fn = backend.read if op == \"read\" else backend.write result = bench_case( lambda a=arg, f=fn: f(a), budget_s=budget_s, max_iters=max_iters, ) summary_rows.append( { \"op\": op, \"backend\": backend.name, \"n_nodes\": doc[\"n_nodes\"], \"file_size\": doc[\"file_size\"], \"median_s\": median(result.samples_s) if result.samples_s else float(\"nan\"), \"n_samples\": len(result.samples_s), \"calls\": result.calls, \"elapsed_s\": result.elapsed_s, } ) return pd.DataFrame(summary_rows).sort_values([\"file_size\", \"backend\"]) def ratio_table_df( summary: pd.DataFrame, backend_order: list[str], ) -> tuple[pd.DataFrame, list[str]]: pivot = ( summary.pivot(index=\"backend\", columns=\"file_size\", values=\"median_s\") .reindex(backend_order) ) picked = nearest_sizes(list(pivot.columns)) size_cols = [size for size, _ in picked] labels = [fmt_bytes_rounded(target) for _, target in picked] ratio = pivot[size_cols].div(pivot.loc[\"yaml12\", size_cols], axis=1) ratio.columns = labels out = ratio.reset_index().rename(columns={\"backend\": \"Backend\"}) return out, labels def plot_perf( summary: pd.DataFrame, *, title: str, ) -> None: size_min = float(summary[\"file_size\"].min()) size_max = float(summary[\"file_size\"].max()) exp_min = max(0, int(math.floor(math.log(size_min, 1024)))) exp_max = max(exp_min, int(math.ceil(math.log(size_max, 1024)))) candidates = [ (1024**power) * mult for power in range(exp_min, exp_max + 1) for mult in (1, 10, 100) ] forced_break = 10 * 1024**2 size_limit_max = max(size_max, forced_break) if forced_break not in candidates: candidates.append(forced_break) breaks = [value for value in candidates if size_min <= value <= size_limit_max] minor_candidates = [ (1024**power) * mult * minor for power in range(exp_min, exp_max + 1) for mult in (1, 10, 100) for minor in range(2, 10) ] minor_breaks = sorted( { value for value in minor_candidates if size_min <= value <= size_limit_max } - set(breaks) ) time_breaks = [1e-4, 1e-3, 1e-2, 1e-1, 1.0, 10.0] time_minor_breaks = sorted( { (10**power) * mult for power in range(-4, 2) for mult in range(2, 10) if 1e-4 <= (10**power) * mult <= 10.0 } - set(time_breaks) ) p = ( ggplot(summary, aes(x=\"file_size\", y=\"median_s\", color=\"backend\")) + geom_point() + geom_line() + labs(title=title, x=\"File size\", y=\"Median time\") + scale_x_log10( breaks=breaks, limits=(size_min, size_limit_max), minor_breaks=minor_breaks, labels=lambda xs: [fmt_bytes(x) for x in xs], ) + scale_y_log10( breaks=time_breaks, minor_breaks=time_minor_breaks, labels=lambda ys: [fmt_time_s(y) for y in ys], ) + theme_minimal(base_size=12) + theme( panel_grid_major=element_line(color=\"#c4c4c4\", size=0.6), panel_grid_minor=element_line(color=\"#dddddd\", size=0.4), ) ) display(p) def render_ratio_table( summary: pd.DataFrame, *, title: str, subtitle: str, backend_order: list[str], ) -> None: table_df, vs_cols = ratio_table_df(summary, backend_order) col_widths = {col: \"90px\" for col in vs_cols} table = ( GT(table_df, rowname_col=\"Backend\") .tab_header(title=title, subtitle=subtitle) .tab_options( table_width=\"100%\", table_layout=\"fixed\", container_overflow_x=\"auto\", table_font_size=\"12px\", data_row_padding=\"4px\", column_labels_background_color=\"#f5f6fa\", column_labels_font_weight=\"600\", row_striping_background_color=\"#f7f7f7\", row_striping_include_stub=True, row_striping_include_table_body=True, quarto_disable_processing=True, ) .cols_width(col_widths) .cols_align(align=\"right\", columns=vs_cols) .tab_spanner(label=\"File size\", columns=vs_cols) .fmt_number( columns=vs_cols, decimals=1, drop_trailing_zeros=True, drop_trailing_dec_mark=True, pattern=\"{x}x\", ) .tab_style( style=[style.fill(\"#eef2ff\"), style.text(weight=\"bold\")], locations=loc.body(rows=[\"yaml12\"]), ) ) display(HTML(table.as_raw_html(inline_css=True))) def run_section( op: Literal[\"read\", \"write\"], *, title: str, ) -> pd.DataFrame: summary = bench_op( op, docs=docs, backends=backends, budget_s=max_time_s, max_iters=max_iters, ) plot_perf(summary, title=f\"{title} performance\") render_ratio_table( summary, title=f\"{title} summary\", subtitle=\"Relative time vs yaml12\", backend_order=backend_order, ) return summary Generate inputs \u00b6 To benchmark, we create YAML files consisting of a repeating sequence of a small, fixed \u201cmixed\u201d node, repeated 2^(1:max_power) times. This node is designed to exercise the YAML 1.2 core schema (every core type is represented). We generate these files with yaml12.write_yaml() . def make_mixed_node() -> dict: return { \"str\": [ \"Lorem ipsum dolor sit amet, vel accumsan vitae faucibus ultrices leo\", \"neque? Et cursus lacinia, ut, sit donec facilisi eu interdum. Dui\", \"ipsum, vitae ligula commodo convallis ac sed nunc. Ipsum at nec lacus\", \"eros suscipit vitae.\", ], \"block_str\": \"lorem \\n ipsum \\n dolor\\n\", \"bools\": [True, False], \"ints\": [123, -123], \"floats\": [123.456, -123.456], \"null\": None, } max_power = int(max_power) max_iters = int(max_iters) tmp_ctx = tempfile.TemporaryDirectory(prefix=\"yaml12-bench-\") tmp_dir = Path(tmp_ctx.name) def make_yaml_doc(n_nodes: int) -> dict: path = tmp_dir / f\"mixed_{n_nodes}.yaml\" obj = [make_mixed_node() for _ in range(n_nodes)] yaml12.write_yaml(obj, path) return { \"n_nodes\": n_nodes, \"path\": str(path), \"file_size\": path.stat().st_size, \"obj\": obj, } docs = [make_yaml_doc(2**p) for p in range(1, max_power + 1)] Backends \u00b6 ## read def _yaml12_read(path: str): return yaml12.read_yaml(path) def _pyyaml_default_read(path: str): with open(path, encoding=\"utf-8\") as f: return yaml.safe_load(f) def _pyyaml_fast_read(path: str): with open(path, encoding=\"utf-8\") as f: return yaml.load(f, Loader=yaml.CSafeLoader) ruyaml_loader_emitter = ruyaml.YAML(typ=\"safe\") def _ruyaml_read(path: str): with open(path, encoding=\"utf-8\") as f: return ruyaml_loader_emitter.load(f) ## write def _yaml12_write(obj): return yaml12.write_yaml(obj, os.devnull) def _pyyaml_default_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return yaml.safe_dump(obj, f) def _pyyaml_fast_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return yaml.dump(obj, f, Dumper=yaml.CSafeDumper, sort_keys=False) def _ruyaml_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return ruyaml_loader_emitter.dump(obj, f) backends = [ Backend( name=\"yaml12\", read=_yaml12_read, write=_yaml12_write, ), Backend( name=\"pyyaml (default)\", read=_pyyaml_default_read, write=_pyyaml_default_write, ), Backend( name=\"pyyaml (fast: CSafeLoader/CSafeDumper)\", read=_pyyaml_fast_read, write=_pyyaml_fast_write, ), Backend( name=\"ruyaml\", read=_ruyaml_read, write=_ruyaml_write, ), ] backend_order = [backend.name for backend in backends] Read performance \u00b6 read_summary = run_section(\"read\", title=\"Read\") Read summary Relative time vs yaml12 File size 10 KiB 100 KiB 1 MiB 10 MiB yaml12 1x 1x 1x 1x pyyaml (default) 57.1x 65.5x 71.6x 70.6x pyyaml (fast: CSafeLoader/CSafeDumper) 5.1x 6.2x 11.3x 10x ruyaml 94.9x 107.2x 105.7x 106.8x Write performance \u00b6 write_summary = run_section(\"write\", title=\"Write\") Write summary Relative time vs yaml12 File size 10 KiB 100 KiB 1 MiB 10 MiB yaml12 1x 1x 1x 1x pyyaml (default) 86.8x 119.6x 137.6x 127.2x pyyaml (fast: CSafeLoader/CSafeDumper) 12.6x 17.8x 19.4x 26.5x ruyaml 121.4x 169.3x 183x 174.4x","title":"Benchmarks and Performance"},{"location":"benchmarks/#benchmarks-and-performance","text":"","title":"Benchmarks and Performance"},{"location":"benchmarks/#goal","text":"Compare yaml12 performance against: PyYAML (defaults) PyYAML (as fast as possible) ruyaml We intentionally avoid testing semantic differences between YAML 1.1 and 1.2, as well as less-used YAML features like tags and streams. Instead, we focus on the simple default usage of each library. Operations: read : YAML file \u2192 Python object write : Python object \u2192 YAML file","title":"Goal"},{"location":"benchmarks/#reproduce","text":"From the repo root: make venv .venv/bin/python -m pip install py-yaml12 pyyaml ruyaml plotnine pandas jupyter ipykernel great-tables css-inline QUARTO_PYTHON=\"$PWD/.venv/bin/python3\" quarto render benchmarks.qmd","title":"Reproduce"},{"location":"benchmarks/#setup","text":"Tweak these constants for faster iterations. max_power = 15 max_time_s = 1 max_iters = 20_000 from __future__ import annotations from dataclasses import dataclass import math import os import tempfile import time from pathlib import Path from statistics import median from typing import Any, Callable, Literal import pandas as pd import ruyaml import yaml import yaml12 from great_tables import GT, loc, style from IPython.display import HTML, display from plotnine import ( aes, element_line, geom_line, geom_point, ggplot, labs, scale_x_log10, scale_y_log10, theme, theme_minimal, ) def fmt_bytes(n: float) -> str: units = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"] n = float(n) for unit in units: if abs(n) < 1024 or unit == units[-1]: if unit == \"B\": return f\"{n:.0f} {unit}\" s = f\"{n:.1f}\".rstrip(\"0\").rstrip(\".\") return f\"{s} {unit}\" n /= 1024 return f\"{n:.1f} {units[-1]}\" def round_sig(x: float, sig: int = 1) -> float: if x == 0: return 0.0 return round(x, sig - 1 - int(math.floor(math.log10(abs(x))))) def fmt_bytes_rounded(n: float) -> str: units = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"] n = float(n) for idx, unit in enumerate(units): if abs(n) < 1024 or unit == units[-1]: if unit == \"B\": return f\"{n:.0f} {unit}\" rounded = round_sig(n, 1) if rounded >= 1000 and idx + 1 < len(units): n = n / 1024 unit = units[idx + 1] rounded = round_sig(n, 1) return f\"{rounded:.0f} {unit}\" n /= 1024 return f\"{n:.1f} {units[-1]}\" def fmt_time_s(sec: float) -> str: sec = float(sec) if sec < 1e-6: return f\"{sec * 1e9:.0f} ns\" if sec < 1e-3: return f\"{sec * 1e6:.1f}\".rstrip(\"0\").rstrip(\".\") + \" \u00b5s\" if sec < 1.0: return f\"{sec * 1e3:.1f}\".rstrip(\"0\").rstrip(\".\") + \" ms\" return f\"{sec:.2f}\".rstrip(\"0\").rstrip(\".\") + \" s\" SIZE_TARGETS = tuple(10**power for power in range(4, 8)) def nearest_sizes( sizes: list[int], targets: tuple[int, ...] = SIZE_TARGETS, ) -> list[tuple[int, int]]: sizes = sorted(set(sizes)) picked: list[tuple[int, int]] = [] used: set[int] = set() for target in targets: size = min(sizes, key=lambda s: abs(s - target)) if size in used: continue used.add(size) picked.append((size, target)) return picked @dataclass(frozen=True) class BenchResult: samples_s: list[float] calls: int elapsed_s: float def bench_case( fn, *, budget_s: float, max_iters: int, ) -> BenchResult: samples: list[float] = [] calls = 0 start = time.perf_counter() while calls < max_iters: t0 = time.perf_counter() fn() t1 = time.perf_counter() samples.append(t1 - t0) calls += 1 if (t1 - start) >= budget_s: break return BenchResult(samples_s=samples, calls=calls, elapsed_s=time.perf_counter() - start) @dataclass(frozen=True) class Backend: name: str read: Callable[[str], Any] write: Callable[[Any], Any] def bench_op( op: Literal[\"read\", \"write\"], *, docs: list[dict], backends: list[Backend], budget_s: float, max_iters: int, ) -> pd.DataFrame: summary_rows: list[dict] = [] for doc in docs: arg = doc[\"path\"] if op == \"read\" else doc[\"obj\"] for backend in backends: fn = backend.read if op == \"read\" else backend.write result = bench_case( lambda a=arg, f=fn: f(a), budget_s=budget_s, max_iters=max_iters, ) summary_rows.append( { \"op\": op, \"backend\": backend.name, \"n_nodes\": doc[\"n_nodes\"], \"file_size\": doc[\"file_size\"], \"median_s\": median(result.samples_s) if result.samples_s else float(\"nan\"), \"n_samples\": len(result.samples_s), \"calls\": result.calls, \"elapsed_s\": result.elapsed_s, } ) return pd.DataFrame(summary_rows).sort_values([\"file_size\", \"backend\"]) def ratio_table_df( summary: pd.DataFrame, backend_order: list[str], ) -> tuple[pd.DataFrame, list[str]]: pivot = ( summary.pivot(index=\"backend\", columns=\"file_size\", values=\"median_s\") .reindex(backend_order) ) picked = nearest_sizes(list(pivot.columns)) size_cols = [size for size, _ in picked] labels = [fmt_bytes_rounded(target) for _, target in picked] ratio = pivot[size_cols].div(pivot.loc[\"yaml12\", size_cols], axis=1) ratio.columns = labels out = ratio.reset_index().rename(columns={\"backend\": \"Backend\"}) return out, labels def plot_perf( summary: pd.DataFrame, *, title: str, ) -> None: size_min = float(summary[\"file_size\"].min()) size_max = float(summary[\"file_size\"].max()) exp_min = max(0, int(math.floor(math.log(size_min, 1024)))) exp_max = max(exp_min, int(math.ceil(math.log(size_max, 1024)))) candidates = [ (1024**power) * mult for power in range(exp_min, exp_max + 1) for mult in (1, 10, 100) ] forced_break = 10 * 1024**2 size_limit_max = max(size_max, forced_break) if forced_break not in candidates: candidates.append(forced_break) breaks = [value for value in candidates if size_min <= value <= size_limit_max] minor_candidates = [ (1024**power) * mult * minor for power in range(exp_min, exp_max + 1) for mult in (1, 10, 100) for minor in range(2, 10) ] minor_breaks = sorted( { value for value in minor_candidates if size_min <= value <= size_limit_max } - set(breaks) ) time_breaks = [1e-4, 1e-3, 1e-2, 1e-1, 1.0, 10.0] time_minor_breaks = sorted( { (10**power) * mult for power in range(-4, 2) for mult in range(2, 10) if 1e-4 <= (10**power) * mult <= 10.0 } - set(time_breaks) ) p = ( ggplot(summary, aes(x=\"file_size\", y=\"median_s\", color=\"backend\")) + geom_point() + geom_line() + labs(title=title, x=\"File size\", y=\"Median time\") + scale_x_log10( breaks=breaks, limits=(size_min, size_limit_max), minor_breaks=minor_breaks, labels=lambda xs: [fmt_bytes(x) for x in xs], ) + scale_y_log10( breaks=time_breaks, minor_breaks=time_minor_breaks, labels=lambda ys: [fmt_time_s(y) for y in ys], ) + theme_minimal(base_size=12) + theme( panel_grid_major=element_line(color=\"#c4c4c4\", size=0.6), panel_grid_minor=element_line(color=\"#dddddd\", size=0.4), ) ) display(p) def render_ratio_table( summary: pd.DataFrame, *, title: str, subtitle: str, backend_order: list[str], ) -> None: table_df, vs_cols = ratio_table_df(summary, backend_order) col_widths = {col: \"90px\" for col in vs_cols} table = ( GT(table_df, rowname_col=\"Backend\") .tab_header(title=title, subtitle=subtitle) .tab_options( table_width=\"100%\", table_layout=\"fixed\", container_overflow_x=\"auto\", table_font_size=\"12px\", data_row_padding=\"4px\", column_labels_background_color=\"#f5f6fa\", column_labels_font_weight=\"600\", row_striping_background_color=\"#f7f7f7\", row_striping_include_stub=True, row_striping_include_table_body=True, quarto_disable_processing=True, ) .cols_width(col_widths) .cols_align(align=\"right\", columns=vs_cols) .tab_spanner(label=\"File size\", columns=vs_cols) .fmt_number( columns=vs_cols, decimals=1, drop_trailing_zeros=True, drop_trailing_dec_mark=True, pattern=\"{x}x\", ) .tab_style( style=[style.fill(\"#eef2ff\"), style.text(weight=\"bold\")], locations=loc.body(rows=[\"yaml12\"]), ) ) display(HTML(table.as_raw_html(inline_css=True))) def run_section( op: Literal[\"read\", \"write\"], *, title: str, ) -> pd.DataFrame: summary = bench_op( op, docs=docs, backends=backends, budget_s=max_time_s, max_iters=max_iters, ) plot_perf(summary, title=f\"{title} performance\") render_ratio_table( summary, title=f\"{title} summary\", subtitle=\"Relative time vs yaml12\", backend_order=backend_order, ) return summary","title":"Setup"},{"location":"benchmarks/#generate-inputs","text":"To benchmark, we create YAML files consisting of a repeating sequence of a small, fixed \u201cmixed\u201d node, repeated 2^(1:max_power) times. This node is designed to exercise the YAML 1.2 core schema (every core type is represented). We generate these files with yaml12.write_yaml() . def make_mixed_node() -> dict: return { \"str\": [ \"Lorem ipsum dolor sit amet, vel accumsan vitae faucibus ultrices leo\", \"neque? Et cursus lacinia, ut, sit donec facilisi eu interdum. Dui\", \"ipsum, vitae ligula commodo convallis ac sed nunc. Ipsum at nec lacus\", \"eros suscipit vitae.\", ], \"block_str\": \"lorem \\n ipsum \\n dolor\\n\", \"bools\": [True, False], \"ints\": [123, -123], \"floats\": [123.456, -123.456], \"null\": None, } max_power = int(max_power) max_iters = int(max_iters) tmp_ctx = tempfile.TemporaryDirectory(prefix=\"yaml12-bench-\") tmp_dir = Path(tmp_ctx.name) def make_yaml_doc(n_nodes: int) -> dict: path = tmp_dir / f\"mixed_{n_nodes}.yaml\" obj = [make_mixed_node() for _ in range(n_nodes)] yaml12.write_yaml(obj, path) return { \"n_nodes\": n_nodes, \"path\": str(path), \"file_size\": path.stat().st_size, \"obj\": obj, } docs = [make_yaml_doc(2**p) for p in range(1, max_power + 1)]","title":"Generate inputs"},{"location":"benchmarks/#backends","text":"## read def _yaml12_read(path: str): return yaml12.read_yaml(path) def _pyyaml_default_read(path: str): with open(path, encoding=\"utf-8\") as f: return yaml.safe_load(f) def _pyyaml_fast_read(path: str): with open(path, encoding=\"utf-8\") as f: return yaml.load(f, Loader=yaml.CSafeLoader) ruyaml_loader_emitter = ruyaml.YAML(typ=\"safe\") def _ruyaml_read(path: str): with open(path, encoding=\"utf-8\") as f: return ruyaml_loader_emitter.load(f) ## write def _yaml12_write(obj): return yaml12.write_yaml(obj, os.devnull) def _pyyaml_default_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return yaml.safe_dump(obj, f) def _pyyaml_fast_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return yaml.dump(obj, f, Dumper=yaml.CSafeDumper, sort_keys=False) def _ruyaml_write(obj): with open(os.devnull, \"w\", encoding=\"utf-8\") as f: return ruyaml_loader_emitter.dump(obj, f) backends = [ Backend( name=\"yaml12\", read=_yaml12_read, write=_yaml12_write, ), Backend( name=\"pyyaml (default)\", read=_pyyaml_default_read, write=_pyyaml_default_write, ), Backend( name=\"pyyaml (fast: CSafeLoader/CSafeDumper)\", read=_pyyaml_fast_read, write=_pyyaml_fast_write, ), Backend( name=\"ruyaml\", read=_ruyaml_read, write=_ruyaml_write, ), ] backend_order = [backend.name for backend in backends]","title":"Backends"},{"location":"benchmarks/#read-performance","text":"read_summary = run_section(\"read\", title=\"Read\") Read summary Relative time vs yaml12 File size 10 KiB 100 KiB 1 MiB 10 MiB yaml12 1x 1x 1x 1x pyyaml (default) 57.1x 65.5x 71.6x 70.6x pyyaml (fast: CSafeLoader/CSafeDumper) 5.1x 6.2x 11.3x 10x ruyaml 94.9x 107.2x 105.7x 106.8x","title":"Read performance"},{"location":"benchmarks/#write-performance","text":"write_summary = run_section(\"write\", title=\"Write\") Write summary Relative time vs yaml12 File size 10 KiB 100 KiB 1 MiB 10 MiB yaml12 1x 1x 1x 1x pyyaml (default) 86.8x 119.6x 137.6x 127.2x pyyaml (fast: CSafeLoader/CSafeDumper) 12.6x 17.8x 19.4x 26.5x ruyaml 121.4x 169.3x 183x 174.4x","title":"Write performance"},{"location":"reference/","text":"Reference \u00b6 All functions \u00b6 parse_yaml() and read_yaml() : Parse YAML 1.2 text or files into Python structures. format_yaml() and write_yaml() : Format or write Python objects as YAML 1.2.","title":"Overview"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#all-functions","text":"parse_yaml() and read_yaml() : Parse YAML 1.2 text or files into Python structures. format_yaml() and write_yaml() : Format or write Python objects as YAML 1.2.","title":"All functions"},{"location":"reference/format_yaml/","text":"Format or write Python objects as YAML 1.2. \u00b6 format_yaml() returns YAML as a string. write_yaml() writes a YAML stream to a file or writer. Both functions honor Yaml tags on values and mapping keys; scalar core tags ( !!str , !!int , !!bool , !!float , !!null , !!seq , !!map ) are dropped on emit because they add no extra information. Mappings are emitted in insertion order (the order you inserted keys into the Python mapping). Usage \u00b6 format_yaml(value, multi=False) write_yaml(value, path=None, multi=False) Arguments \u00b6 value: Any combination of Python scalars, lists, and dicts; tagged values or mapping keys can be wrapped in Yaml . When multi=True , value must be a sequence of documents. multi: When True , treat value as a list of YAML documents and encode a stream separated by --- and terminated with ... . path: Destination path ( str or os.PathLike ) or writable object with .write() . When None , write to stdout. Writers must accept str ; for binary sinks open the file in text mode or wrap the stream with io.TextIOWrapper(...) . Returns \u00b6 format_yaml() returns a str containing YAML (ending with ...\\n for multi-document output); single-document output omits the leading --- marker and trailing newline. write_yaml() returns None . Examples \u00b6 from pathlib import Path from yaml12 import Yaml, format_yaml, write_yaml format_yaml({\"foo\": 1, \"bar\": [True, None]}) # 'foo: 1\\nbar:\\n - true\\n - ~' docs = [{\"foo\": 1}, {\"bar\": [2, None]}] format_yaml(docs, multi=True) # '---\\nfoo: 1\\n---\\nbar:\\n - 2\\n - ~\\n...\\n' tagged = Yaml(\"1 + 1\", \"!expr\") format_yaml(tagged) # '!expr 1 + 1' path = Path(\"example.yaml\") write_yaml({\"alpha\": 1}, path) assert path.read_text(encoding=\"utf-8\") == f\"---\\n{format_yaml({'alpha': 1})}\\n...\\n\"","title":"format_yaml() and write_yaml()"},{"location":"reference/format_yaml/#format-or-write-python-objects-as-yaml-12","text":"format_yaml() returns YAML as a string. write_yaml() writes a YAML stream to a file or writer. Both functions honor Yaml tags on values and mapping keys; scalar core tags ( !!str , !!int , !!bool , !!float , !!null , !!seq , !!map ) are dropped on emit because they add no extra information. Mappings are emitted in insertion order (the order you inserted keys into the Python mapping).","title":"Format or write Python objects as YAML 1.2."},{"location":"reference/format_yaml/#usage","text":"format_yaml(value, multi=False) write_yaml(value, path=None, multi=False)","title":"Usage"},{"location":"reference/format_yaml/#arguments","text":"value: Any combination of Python scalars, lists, and dicts; tagged values or mapping keys can be wrapped in Yaml . When multi=True , value must be a sequence of documents. multi: When True , treat value as a list of YAML documents and encode a stream separated by --- and terminated with ... . path: Destination path ( str or os.PathLike ) or writable object with .write() . When None , write to stdout. Writers must accept str ; for binary sinks open the file in text mode or wrap the stream with io.TextIOWrapper(...) .","title":"Arguments"},{"location":"reference/format_yaml/#returns","text":"format_yaml() returns a str containing YAML (ending with ...\\n for multi-document output); single-document output omits the leading --- marker and trailing newline. write_yaml() returns None .","title":"Returns"},{"location":"reference/format_yaml/#examples","text":"from pathlib import Path from yaml12 import Yaml, format_yaml, write_yaml format_yaml({\"foo\": 1, \"bar\": [True, None]}) # 'foo: 1\\nbar:\\n - true\\n - ~' docs = [{\"foo\": 1}, {\"bar\": [2, None]}] format_yaml(docs, multi=True) # '---\\nfoo: 1\\n---\\nbar:\\n - 2\\n - ~\\n...\\n' tagged = Yaml(\"1 + 1\", \"!expr\") format_yaml(tagged) # '!expr 1 + 1' path = Path(\"example.yaml\") write_yaml({\"alpha\": 1}, path) assert path.read_text(encoding=\"utf-8\") == f\"---\\n{format_yaml({'alpha': 1})}\\n...\\n\"","title":"Examples"},{"location":"reference/parse_yaml/","text":"Parse YAML 1.2 text or files into Python objects. \u00b6 parse_yaml() takes YAML text; read_yaml() reads from a path or a streaming reader. Usage \u00b6 parse_yaml(text, multi=False, handlers=None) read_yaml(path, multi=False, handlers=None) Arguments \u00b6 text: str or iterable of str ; chunks are concatenated exactly as provided (no implicit separators are inserted). When empty, returns None (or [] when multi=True ). path: str , os.PathLike , or readable object yielding str or UTF-8 bytes . multi: When True , parse the whole stream and return a list of documents; when False , stop after the first document. handlers: Optional dict[str, Callable] keyed by YAML tag strings; matching handlers transform tagged values and keys. Exceptions from handlers propagate unchanged. Returns \u00b6 When multi=False , the first document or None for empty input. When multi=True , a list of all documents. Tagged nodes without a matching handler (including informative core tags such as !!timestamp or !!binary ) become Yaml objects. Unhashable mapping keys are wrapped in Yaml so they remain hashable. Mapping key order is preserved in the returned dict (in the same order keys appear in the YAML input). Examples \u00b6 from yaml12 import parse_yaml parse_yaml(\"foo: [1, 2, 3]\") # {'foo': [1, 2, 3]} stream = \"\"\" --- first: 1 --- second: 2 \"\"\" parse_yaml(stream) # returns {'first': 1} parse_yaml(stream, multi=True) # returns [{'first': 1}, {'second': 2}] handlers = {\"!upper\": lambda value: str(value).upper()} parse_yaml(\"!upper key: !upper value\", handlers=handlers) # {'KEY': 'VALUE'} lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] parse_yaml(\"\\n\".join(lines)) # {'title': 'Front matter only', 'params': {'answer': 42}}","title":"parse_yaml() and read_yaml()"},{"location":"reference/parse_yaml/#parse-yaml-12-text-or-files-into-python-objects","text":"parse_yaml() takes YAML text; read_yaml() reads from a path or a streaming reader.","title":"Parse YAML 1.2 text or files into Python objects."},{"location":"reference/parse_yaml/#usage","text":"parse_yaml(text, multi=False, handlers=None) read_yaml(path, multi=False, handlers=None)","title":"Usage"},{"location":"reference/parse_yaml/#arguments","text":"text: str or iterable of str ; chunks are concatenated exactly as provided (no implicit separators are inserted). When empty, returns None (or [] when multi=True ). path: str , os.PathLike , or readable object yielding str or UTF-8 bytes . multi: When True , parse the whole stream and return a list of documents; when False , stop after the first document. handlers: Optional dict[str, Callable] keyed by YAML tag strings; matching handlers transform tagged values and keys. Exceptions from handlers propagate unchanged.","title":"Arguments"},{"location":"reference/parse_yaml/#returns","text":"When multi=False , the first document or None for empty input. When multi=True , a list of all documents. Tagged nodes without a matching handler (including informative core tags such as !!timestamp or !!binary ) become Yaml objects. Unhashable mapping keys are wrapped in Yaml so they remain hashable. Mapping key order is preserved in the returned dict (in the same order keys appear in the YAML input).","title":"Returns"},{"location":"reference/parse_yaml/#examples","text":"from yaml12 import parse_yaml parse_yaml(\"foo: [1, 2, 3]\") # {'foo': [1, 2, 3]} stream = \"\"\" --- first: 1 --- second: 2 \"\"\" parse_yaml(stream) # returns {'first': 1} parse_yaml(stream, multi=True) # returns [{'first': 1}, {'second': 2}] handlers = {\"!upper\": lambda value: str(value).upper()} parse_yaml(\"!upper key: !upper value\", handlers=handlers) # {'KEY': 'VALUE'} lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] parse_yaml(\"\\n\".join(lines)) # {'title': 'Front matter only', 'params': {'answer': 42}}","title":"Examples"}]}